{"version":3,"file":"index.es.js","sources":["../src/bitcoinish/types.ts","../src/bitcoinish/utils.ts","../src/bitcoinish/BlockbookConnected.ts","../src/bitcoinish/BitcoinishPaymentsUtils.ts","../src/bitcoinish/BitcoinishPayments.ts","../src/types.ts","../src/constants.ts","../src/utils.ts","../src/helpers.ts","../src/BaseBitcoinPayments.ts","../src/bip44.ts","../src/SinglesigBitcoinPayments.ts","../src/HdBitcoinPayments.ts","../src/BitcoinPaymentsUtils.ts","../src/KeyPairBitcoinPayments.ts","../src/MultisigBitcoinPayments.ts","../src/BitcoinPaymentsFactory.ts"],"sourcesContent":["import * as t from 'io-ts'\nimport {\n  BaseUnsignedTransaction, BaseSignedTransaction, FeeRate, AutoFeeLevels,\n  BaseTransactionInfo, BaseBroadcastResult, UtxoInfo, NetworkTypeT, ResolveablePayport,\n} from '@faast/payments-common'\nimport { extendCodec, nullable, instanceofCodec, requiredOptionalCodec, Logger, Numeric } from '@faast/ts-common'\nimport { Network as BitcoinjsNetwork } from 'bitcoinjs-lib'\nimport { BlockbookBitcoin, BlockInfoBitcoin } from 'blockbook-client'\n\nexport { BitcoinjsNetwork, UtxoInfo }\n\n/** A hack to get around TS2742 when config is re-exported from coin-payments */\nexport class BlockbookServerAPI extends BlockbookBitcoin {}\n\nexport const BlockbookConfigServer = t.union([\n  t.string,\n  t.array(t.string),\n  instanceofCodec(BlockbookServerAPI),\n  t.null,\n], 'BlockbookConfigServer')\nexport type BlockbookConfigServer = t.TypeOf<typeof BlockbookConfigServer>\n\nexport const BlockbookConnectedConfig = requiredOptionalCodec(\n  {\n    network: NetworkTypeT,\n    server: BlockbookConfigServer,\n  },\n  {\n    logger: nullable(Logger),\n  },\n  'BlockbookConnectedConfig',\n)\nexport type BlockbookConnectedConfig = t.TypeOf<typeof BlockbookConnectedConfig>\n\nexport type BitcoinishPaymentsUtilsConfig = BlockbookConnectedConfig & {\n  coinSymbol: string,\n  coinName: string,\n  bitcoinjsNetwork: BitcoinjsNetwork,\n  decimals: number,\n}\n\nexport type BitcoinishPaymentsConfig = BitcoinishPaymentsUtilsConfig & {\n  minTxFee: FeeRate,\n  dustThreshold: number,\n  networkMinRelayFee: number,\n  defaultFeeLevel: AutoFeeLevels,\n  targetUtxoPoolSize?: number, // # of available utxos to try and maintain\n  minChange?: Numeric, // Soft minimum for each change generated to maintain utxo pool\n}\n\nexport const BitcoinishTxOutput = t.type({\n  address: t.string,\n  value: t.string,\n}, 'BitcoinishTxOutput')\nexport type BitcoinishTxOutput = t.TypeOf<typeof BitcoinishTxOutput>\n\nexport const BitcoinishTxOutputSatoshis = t.type({\n  address: t.string,\n  satoshis: t.number,\n}, 'BitcoinishTxOutputSatoshis')\nexport type BitcoinishTxOutputSatoshis = t.TypeOf<typeof BitcoinishTxOutputSatoshis>\n\nexport const BitcoinishWeightedChangeOutput = t.type({\n  address: t.string,\n  weight: t.number,\n}, 'BitcoinishWeightedChangeOutput')\nexport type BitcoinishWeightedChangeOutput = t.TypeOf<typeof BitcoinishWeightedChangeOutput>\n\n/**\n * An object representing a Bitcoin like transaction (UTXO based) with inputs and outputs.\n *\n * The externalOutputs, changeOutputs, and hex fields are optional for back compat. Single change output\n * transactions use the changeAddress field. Multi change outputs transactions will leave\n * changeAddress null.\n */\nexport const BitcoinishPaymentTx = requiredOptionalCodec(\n  {\n    inputs: t.array(UtxoInfo),\n    // All external and change outputs\n    outputs: t.array(BitcoinishTxOutput),\n    fee: t.string,\n    change: t.string,\n    changeAddress: nullable(t.string),\n  },\n  {\n    // Outputs specified by transaction creator\n    externalOutputs: t.array(BitcoinishTxOutput),\n    // Total of external outputs in main denom\n    externalOutputTotal: t.string,\n    // Outputs returning to transaction creator\n    changeOutputs: t.array(BitcoinishTxOutput),\n    // Unsigned tx serialized as hex string (if implementation allows, empty string otherwise)\n    rawHex: t.string,\n    // sha256 hash of raw tx data\n    rawHash: t.string,\n  },\n  'BitcoinishPaymentTx'\n)\nexport type BitcoinishPaymentTx = t.TypeOf<typeof BitcoinishPaymentTx>\n\nexport const BitcoinishUnsignedTransaction = extendCodec(\n  BaseUnsignedTransaction,\n  {\n    amount: t.string,\n    fee: t.string,\n    data: BitcoinishPaymentTx,\n  },\n  'BitcoinishUnsignedTransaction',\n)\nexport type BitcoinishUnsignedTransaction = t.TypeOf<typeof BitcoinishUnsignedTransaction>\n\nexport const BitcoinishSignedTransaction = extendCodec(BaseSignedTransaction, {\n  data: t.type({\n    hex: t.string,\n  }),\n}, {}, 'BitcoinishSignedTransaction')\nexport type BitcoinishSignedTransaction = t.TypeOf<typeof BitcoinishSignedTransaction>\n\nexport const BitcoinishTransactionInfo = extendCodec(BaseTransactionInfo, {}, {}, 'BitcoinishTransactionInfo')\nexport type BitcoinishTransactionInfo = t.TypeOf<typeof BitcoinishTransactionInfo>\n\nexport const BitcoinishBroadcastResult = extendCodec(BaseBroadcastResult, {}, {}, 'BitcoinishBroadcastResult')\nexport type BitcoinishBroadcastResult = t.TypeOf<typeof BitcoinishBroadcastResult>\n\nexport const BitcoinishBlock = BlockInfoBitcoin\nexport type BitcoinishBlock = BlockInfoBitcoin\n\nexport const PayportOutput = t.type({\n  payport: ResolveablePayport,\n  amount: Numeric,\n}, 'PayportOutput')\nexport type PayportOutput = t.TypeOf<typeof PayportOutput>\n","import { NetworkType, UtxoInfo } from '@faast/payments-common'\nimport { BlockbookConnectedConfig, BitcoinishTxOutput, BitcoinishTxOutputSatoshis } from './types';\nimport { BlockbookBitcoin } from 'blockbook-client'\nimport { isString, Logger, isMatchingError, toBigNumber } from '@faast/ts-common'\nimport promiseRetry from 'promise-retry'\nimport BigNumber from 'bignumber.js'\nimport crypto from 'crypto'\n\nexport function resolveServer(server: BlockbookConnectedConfig['server'], network: NetworkType): {\n  api: BlockbookBitcoin\n  server: string[] | null\n} {\n  if (isString(server)) {\n    return {\n      api: new BlockbookBitcoin({\n        nodes: [server],\n      }),\n      server: [server],\n    }\n  } else if (server instanceof BlockbookBitcoin) {\n    return {\n      api: server,\n      server: server.nodes,\n    }\n  } else if (Array.isArray(server)) {\n    return {\n      api: new BlockbookBitcoin({\n        nodes: server,\n      }),\n      server,\n    }\n  } else {\n    // null server arg -> offline mode\n    return {\n      api: new BlockbookBitcoin({\n        nodes: [''],\n      }),\n      server: null,\n    }\n  }\n}\n\nconst RETRYABLE_ERRORS = ['timeout', 'disconnected']\nconst MAX_RETRIES = 3\n\nexport function retryIfDisconnected<T>(fn: () => Promise<T>, api: BlockbookBitcoin, logger: Logger): Promise<T> {\n  return promiseRetry(\n    (retry, attempt) => {\n      return fn().catch(async e => {\n        if (isMatchingError(e, RETRYABLE_ERRORS)) {\n          logger.log(\n            `Retryable error during blockbook server call, retrying ${MAX_RETRIES - attempt} more times`,\n            e.toString(),\n          )\n          retry(e)\n        }\n        throw e\n      })\n    },\n    {\n      retries: MAX_RETRIES,\n    },\n  )\n}\n\n// in most cases (P2PKH):\n// 10 = version: 4, locktime: 4, inputs and outputs count: 1\n// 148 = txId: 32, vout: 4, count: 1, script: 107, sequence: 4\n// 34 = value: 8, count: 1, scriptPubKey: 25\n// This esimate also appears accurate for P2WPKH\nexport function estimateTxSize (inputsCount: number, outputsCount: number, handleSegwit: boolean) {\n  return 10 + (148 * inputsCount) + (34 * outputsCount)\n}\n\nexport function estimateTxFee (satPerByte: number, inputsCount: number, outputsCount: number, handleSegwit: boolean) {\n  return estimateTxSize(inputsCount, outputsCount, handleSegwit) * satPerByte\n}\n\n/**\n * Sum the utxos values (main denomination)\n */\nexport function sumUtxoValue(utxos: UtxoInfo[], includeUnconfirmed?: boolean): BigNumber {\n  const filtered = includeUnconfirmed ? utxos : utxos.filter(isConfirmedUtxo)\n  return filtered.reduce((total, { value }) => total.plus(value), toBigNumber(0))\n}\n\n/**\n * Sort the utxos for input selection\n */\nexport function sortUtxos<T extends UtxoInfo>(utxoList: T[]): T[] {\n  const result = [...utxoList]\n  result.sort((a, b) => toBigNumber(a.value).minus(b.value).toNumber()) // Ascending order by value\n  return result\n}\n\nexport function isConfirmedUtxo(utxo: UtxoInfo): boolean {\n  return Boolean((utxo.confirmations && utxo.confirmations > 0) || (utxo.height && Number.parseInt(utxo.height) > 0))\n}\n\nexport function sha256FromHex(hex: string): string {\n  return hex\n    ? crypto.createHash('sha256').update(Buffer.from(hex, 'hex')).digest('hex')\n    : ''\n}\n","import { NetworkType } from '@faast/payments-common'\nimport { Logger, assertType, DelegateLogger } from '@faast/ts-common'\nimport { BlockbookBitcoin } from 'blockbook-client'\n\nimport { BlockbookConnectedConfig } from './types'\nimport { DEFAULT_NETWORK, PACKAGE_NAME } from '../constants'\nimport { resolveServer, retryIfDisconnected } from './utils'\n\nexport abstract class BlockbookConnected {\n  networkType: NetworkType\n  logger: Logger\n  api: BlockbookBitcoin | null\n  server: string[] | null\n\n  constructor(config: BlockbookConnectedConfig) {\n    assertType(BlockbookConnectedConfig, config)\n    this.networkType = config.network\n    this.logger = new DelegateLogger(config.logger)\n    const { api, server } = resolveServer(config.server, this.networkType)\n    this.api = api\n    this.server = server\n  }\n\n  getApi(): BlockbookBitcoin {\n    if (this.api === null) {\n      throw new Error('Cannot access Bitcoin network when configured with null server')\n    }\n    return this.api\n  }\n\n  async init(): Promise<void> {}\n\n  async destroy(): Promise<void> {}\n\n  async _retryDced<T>(fn: () => Promise<T>): Promise<T> {\n    return retryIfDisconnected(fn, this.getApi(), this.logger)\n  }\n}\n","import { PaymentsUtils, Payport, createUnitConverters, MaybePromise } from '@faast/payments-common'\nimport { Network as BitcoinjsNetwork } from 'bitcoinjs-lib'\nimport { isNil, assertType, Numeric, isUndefined } from '@faast/ts-common'\nimport { BlockbookConnected } from './BlockbookConnected'\nimport { BitcoinishBlock, BitcoinishPaymentsUtilsConfig } from './types'\n\ntype UnitConverters = ReturnType<typeof createUnitConverters>\n\nexport abstract class BitcoinishPaymentsUtils extends BlockbookConnected implements PaymentsUtils {\n\n  decimals: number\n  bitcoinjsNetwork: BitcoinjsNetwork\n\n  constructor(config: BitcoinishPaymentsUtilsConfig) {\n    super(config)\n    this.decimals = config.decimals\n    this.bitcoinjsNetwork = config.bitcoinjsNetwork\n    const unitConverters = createUnitConverters(this.decimals)\n    this.toMainDenominationString = unitConverters.toMainDenominationString\n    this.toMainDenominationNumber = unitConverters.toMainDenominationNumber\n    this.toMainDenominationBigNumber = unitConverters.toMainDenominationBigNumber\n    this.toBaseDenominationString = unitConverters.toBaseDenominationString\n    this.toBaseDenominationNumber = unitConverters.toBaseDenominationNumber\n    this.toBaseDenominationBigNumber = unitConverters.toBaseDenominationBigNumber\n  }\n\n  isValidExtraId(extraId: string): boolean {\n    return false // utxo coins don't use extraIds\n  }\n\n  abstract isValidAddress(address: string): MaybePromise<boolean>\n\n  private async _getPayportValidationMessage(payport: Payport): Promise<string | undefined> {\n    const { address, extraId } = payport\n    if (!await this.isValidAddress(address)) {\n      return 'Invalid payport address'\n    }\n    if (!isNil(extraId)) {\n      return 'Invalid payport extraId'\n    }\n  }\n\n  async getPayportValidationMessage(payport: Payport): Promise<string | undefined> {\n    try {\n      payport = assertType(Payport, payport, 'payport')\n    } catch (e) {\n      return e.message\n    }\n    return this._getPayportValidationMessage(payport)\n  }\n\n  async validatePayport(payport: Payport): Promise<void> {\n    payport = assertType(Payport, payport, 'payport')\n    const message = await this._getPayportValidationMessage(payport)\n    if (message) {\n      throw new Error(message)\n    }\n  }\n\n  async isValidPayport(payport: Payport): Promise<boolean> {\n    return Payport.is(payport) && !(await this._getPayportValidationMessage(payport))\n  }\n\n  toMainDenomination(amount: Numeric): string {\n    return this.toMainDenominationString(amount)\n  }\n\n  toBaseDenomination(amount: Numeric): string {\n    return this.toBaseDenominationString(amount)\n  }\n\n  toMainDenominationString: UnitConverters['toMainDenominationString']\n  toMainDenominationNumber: UnitConverters['toMainDenominationNumber']\n  toMainDenominationBigNumber: UnitConverters['toMainDenominationBigNumber']\n\n  toBaseDenominationString: UnitConverters['toMainDenominationString']\n  toBaseDenominationNumber: UnitConverters['toMainDenominationNumber']\n  toBaseDenominationBigNumber: UnitConverters['toMainDenominationBigNumber']\n\n  async getBlock(id?: string | number): Promise<BitcoinishBlock> {\n    if (isUndefined(id)) {\n      id = (await this.getApi().getStatus()).backend.bestBlockHash\n    }\n    return this.getApi().getBlock(id)\n  }\n}\n","import {\n  BasePayments, UtxoInfo, FeeOptionCustom, FeeRateType, FeeRate, FeeOption,\n  ResolvedFeeOption, FeeLevel, AutoFeeLevels, Payport, ResolveablePayport,\n  BalanceResult, FromTo, TransactionStatus, CreateTransactionOptions, BaseConfig,\n  WeightedChangeOutput,\n  MaybePromise,\n} from '@faast/payments-common'\nimport { isUndefined, isType, Numeric, toBigNumber, assertType, isNumber, isString } from '@faast/ts-common'\nimport { get } from 'lodash'\nimport * as t from 'io-ts'\n\nimport {\n  BitcoinishUnsignedTransaction,\n  BitcoinishSignedTransaction,\n  BitcoinishBroadcastResult,\n  BitcoinishTransactionInfo,\n  BitcoinishPaymentsConfig,\n  BitcoinishPaymentTx,\n  BitcoinishTxOutput,\n  BitcoinishTxOutputSatoshis,\n  BitcoinishWeightedChangeOutput,\n  PayportOutput,\n} from './types'\nimport { estimateTxFee, sumUtxoValue, sortUtxos, isConfirmedUtxo, sha256FromHex } from './utils';\nimport { BitcoinishPaymentsUtils } from './BitcoinishPaymentsUtils'\n\nexport abstract class BitcoinishPayments<Config extends BaseConfig> extends BitcoinishPaymentsUtils\n  implements BasePayments<\n    Config,\n    BitcoinishUnsignedTransaction,\n    BitcoinishSignedTransaction,\n    BitcoinishBroadcastResult,\n    BitcoinishTransactionInfo\n  > {\n  coinSymbol: string\n  coinName: string\n  minTxFee?: FeeRate\n  dustThreshold: number // base denom\n  networkMinRelayFee: number // base denom\n  defaultFeeLevel: AutoFeeLevels\n  targetUtxoPoolSize: number\n  minChangeSat: number\n\n  constructor(config: BitcoinishPaymentsConfig) {\n    super(config)\n    this.coinSymbol = config.coinSymbol\n    this.coinName = config.coinName\n    this.decimals = config.decimals\n    this.bitcoinjsNetwork = config.bitcoinjsNetwork\n    this.minTxFee = config.minTxFee\n    this.dustThreshold = config.dustThreshold\n    this.networkMinRelayFee = config.networkMinRelayFee\n    this.defaultFeeLevel = config.defaultFeeLevel\n    this.targetUtxoPoolSize = isUndefined(config.targetUtxoPoolSize) ? 1 : config.targetUtxoPoolSize\n    const minChange = toBigNumber(isUndefined(config.minChange) ? 0 : config.minChange)\n    if (minChange.lt(0)) {\n      throw new Error(`invalid minChange amount ${config.minChange}, must be positive`)\n    }\n    this.minChangeSat = this.toBaseDenominationNumber(minChange)\n  }\n\n  abstract getFullConfig(): Config\n  abstract getPublicConfig(): Config\n  abstract getAccountId(index: number): string\n  abstract getAccountIds(index?: number): string[]\n  abstract getAddress(index: number): string\n  abstract getFeeRateRecommendation(feeLevel: AutoFeeLevels): Promise<FeeRate>\n  abstract isValidAddress(address: string): MaybePromise<boolean>\n  abstract signTransaction(tx: BitcoinishUnsignedTransaction): Promise<BitcoinishSignedTransaction>\n\n  /**\n   * Serialize the payment tx into an hex string format representing the unsigned transaction.\n   *\n   * By default return empty string because it's coin dependent. Implementors can override this\n   * with coin specific implementation (eg using Psbt for bitcoin). If coin doesn't have an unsigned\n   * serialized tx format (ie most coins other than BTC) then leave as empty string.\n   */\n  abstract serializePaymentTx(paymentTx: BitcoinishPaymentTx, fromIndex: number): Promise<string>\n\n  async init() {}\n  async destroy() {}\n\n  requiresBalanceMonitor() {\n    return false\n  }\n\n  isSweepableBalance(balance: Numeric): boolean {\n    return this.toBaseDenominationNumber(balance) > this.networkMinRelayFee\n  }\n\n  async getPayport(index: number): Promise<Payport> {\n    return { address: this.getAddress(index) }\n  }\n\n  async resolvePayport(payport: ResolveablePayport): Promise<Payport> {\n    if (typeof payport === 'number') {\n      return this.getPayport(payport)\n    } else if (typeof payport === 'string') {\n      if (!await this.isValidAddress(payport)) {\n        throw new Error(`Invalid BTC address: ${payport}`)\n      }\n      return { address: payport }\n    } else if (Payport.is(payport)) {\n      if (!await this.isValidAddress(payport.address)) {\n        throw new Error(`Invalid BTC payport.address: ${payport.address}`)\n      }\n      return payport\n    } else {\n      throw new Error('Invalid payport')\n    }\n  }\n\n  async resolveFeeOption(\n    feeOption: FeeOption,\n  ): Promise<ResolvedFeeOption> {\n    let targetLevel: FeeLevel\n    let target: FeeRate\n    let feeBase = ''\n    let feeMain = ''\n    if (isType(FeeOptionCustom, feeOption)) {\n      targetLevel = FeeLevel.Custom\n      target = feeOption\n    } else {\n      targetLevel = feeOption.feeLevel || this.defaultFeeLevel\n      target = await this.getFeeRateRecommendation(targetLevel)\n    }\n    if (target.feeRateType === FeeRateType.Base) {\n      feeBase = target.feeRate\n      feeMain = this.toMainDenominationString(feeBase)\n    } else if (target.feeRateType === FeeRateType.Main) {\n      feeMain = target.feeRate\n      feeBase = this.toBaseDenominationString(feeMain)\n    }\n    // in base/weight case total fees depend on input/output count, so just leave them as empty strings\n    return {\n      targetFeeLevel: targetLevel,\n      targetFeeRate: target.feeRate,\n      targetFeeRateType: target.feeRateType,\n      feeBase,\n      feeMain,\n    }\n  }\n\n  async getBalance(payport: ResolveablePayport): Promise<BalanceResult> {\n    const { address } = await this.resolvePayport(payport)\n    const result = await this._retryDced(() => this.getApi().getAddressDetails(address, { details: 'basic' }))\n    const confirmedBalance = this.toMainDenominationString(result.balance)\n    const unconfirmedBalance = this.toMainDenominationString(result.unconfirmedBalance)\n    this.logger.debug('getBalance', address, confirmedBalance, unconfirmedBalance)\n    return {\n      confirmedBalance,\n      unconfirmedBalance,\n      sweepable: this.isSweepableBalance(confirmedBalance)\n    }\n  }\n\n  usesUtxos() {\n    return true\n  }\n\n  async getUtxos(payport: ResolveablePayport): Promise<UtxoInfo[]> {\n    const { address } = await this.resolvePayport(payport)\n    let utxosRaw = await this.getApi().getUtxosForAddress(address)\n    const utxos: UtxoInfo[] = utxosRaw.map((data) => {\n      const { value, height, lockTime } = data\n      return {\n        ...data,\n        satoshis: Number.parseInt(value),\n        value: this.toMainDenominationString(value),\n        height: isUndefined(height) ? undefined : String(height),\n        lockTime: isUndefined(lockTime) ? undefined : String(lockTime),\n      }\n    })\n    return utxos\n  }\n\n  usesSequenceNumber() {\n    return false\n  }\n\n  async getNextSequenceNumber() {\n    return null\n  }\n\n  async resolveFromTo(from: number, to: ResolveablePayport): Promise<FromTo> {\n    const fromPayport = await this.getPayport(from)\n    const toPayport = await this.resolvePayport(to)\n    return {\n      fromAddress: fromPayport.address,\n      fromIndex: from,\n      fromExtraId: fromPayport.extraId,\n      fromPayport,\n      toAddress: toPayport.address,\n      toIndex: typeof to === 'number' ? to : null,\n      toExtraId: toPayport.extraId,\n      toPayport,\n    }\n  }\n\n  /** buildPaymentTx uses satoshi number for convenient math, but we want strings externally */\n  private convertOutputsToExternalFormat(outputs: Array<{ address: string, satoshis: number }>): BitcoinishTxOutput[] {\n    return outputs.map(({ address, satoshis }) => ({ address, value: this.toMainDenominationString(satoshis) }))\n  }\n\n  private feeRateToSatoshis(\n    { feeRate, feeRateType }: FeeRate,\n    inputCount: number,\n    outputCount: number,\n  ): number {\n    if (feeRateType === FeeRateType.BasePerWeight) {\n      return estimateTxFee(Number.parseFloat(feeRate), inputCount, outputCount, true)\n    } else if (feeRateType === FeeRateType.Main) {\n      return this.toBaseDenominationNumber(feeRate)\n    }\n    return Number.parseFloat(feeRate)\n  }\n\n  private calculateTxFeeSatoshis(\n    targetRate: FeeRate,\n    inputCount: number,\n    outputCount: number,\n  ) {\n    let feeSat = this.feeRateToSatoshis(targetRate, inputCount, outputCount)\n    // Ensure calculated fee is above configured minimum\n    if (this.minTxFee) {\n      const minTxFeeSat = this.feeRateToSatoshis(this.minTxFee, inputCount, outputCount)\n      if (feeSat < minTxFeeSat) {\n        this.logger.debug(`Using min tx fee of ${minTxFeeSat} sat (${this.minTxFee} sat/byte) instead of ${feeSat} sat`)\n        feeSat = minTxFeeSat\n      }\n    }\n    // Ensure calculated fee is above network relay minimum\n    if (feeSat < this.networkMinRelayFee) {\n      this.logger.debug(`Using network min relay fee of ${this.networkMinRelayFee} sat instead of ${feeSat} sat`)\n      feeSat = this.networkMinRelayFee\n    }\n    return Math.ceil(feeSat)\n  }\n\n  private selectInputUtxos(\n    availableUtxos: UtxoInfo[], outputTotal: number, outputCount: number, feeRate: FeeRate, useAllUtxos: boolean,\n  ): { selectedUtxos: UtxoInfo[], selectedTotalSat: number, feeSat: number } {\n    // Convert values to satoshis for convenient math\n    const utxos: Array<UtxoInfo & { satoshis: number }> = []\n    let utxosTotalSat = 0\n    for (const utxo of availableUtxos) {\n      const satoshis = isUndefined(utxo.satoshis)\n        ? this.toBaseDenominationNumber(utxo.value)\n        : toBigNumber(utxo.satoshis).toNumber()\n      utxosTotalSat += satoshis\n      utxos.push({\n        ...utxo,\n        satoshis,\n      })\n    }\n\n    if (useAllUtxos) { // Sweeping case\n      return {\n        selectedUtxos: utxos,\n        selectedTotalSat: utxosTotalSat,\n        feeSat: this.calculateTxFeeSatoshis(feeRate, utxos.length, outputCount)\n      }\n    } else { // Sending amount case\n      // First try to find a single input that covers output without creating change\n      const idealSolutionFeeSat = this.calculateTxFeeSatoshis(feeRate, 1, outputCount)\n      const idealSolutionMinSat = outputTotal + idealSolutionFeeSat\n      const idealSolutionMaxSat = idealSolutionMinSat + this.dustThreshold\n      for (const utxo of utxos) {\n        if (utxo.satoshis >= idealSolutionMinSat && utxo.satoshis <= idealSolutionMaxSat) {\n          this.logger.log(\n            `Found ideal ${this.coinSymbol} input utxo solution to send ${outputTotal} sat using single utxo ${utxo.txid}:${utxo.vout}`\n          )\n          return {\n            selectedUtxos: [utxo],\n            selectedTotalSat: utxo.satoshis,\n            feeSat: idealSolutionFeeSat,\n          }\n        }\n      }\n\n      // Select by accumulating smallest utxos first until we cover output + fees\n      let selectedUtxos = []\n      let selectedTotalSat = 0 // Total input sat is accumulated as inputs are added\n      let feeSat = 0 // Total fee is recalculated when adding each input\n      const sortedUtxos = sortUtxos(utxos)\n      for (const utxo of sortedUtxos) {\n        selectedUtxos.push(utxo)\n        selectedTotalSat += utxo.satoshis\n        feeSat = this.calculateTxFeeSatoshis(feeRate, selectedUtxos.length, outputCount)\n        if (selectedTotalSat >= outputTotal + feeSat) {\n          break\n        }\n      }\n      return {\n        selectedUtxos,\n        selectedTotalSat,\n        feeSat,\n      }\n    }\n  }\n\n  /**\n   * Build a simple payment transaction.\n   * Note: fee will be subtracted from first output when attempting to send entire account balance\n   * Note: All amounts/values should be input and output as main denomination strings for consistent\n   * serialization. Within this function they're converted to JS Numbers for convenient arithmetic\n   * then converted back to strings before being returned.\n   */\n  async buildPaymentTx(params: {\n    unusedUtxos: UtxoInfo[], // Utxos not already taken by pending txs\n    desiredOutputs: BitcoinishTxOutput[],\n    changeAddress: string,\n    desiredFeeRate: FeeRate,\n    useAllUtxos?: boolean,\n    useUnconfirmedUtxos?: boolean, // true if unconfirmed utxos should be used\n  }): Promise<Required<BitcoinishPaymentTx>> {\n    const {\n      unusedUtxos, desiredOutputs, changeAddress, desiredFeeRate,\n    } = params\n    const useAllUtxos = isUndefined(params.useAllUtxos) ? false : params.useAllUtxos\n    const useUnconfirmedUtxos = isUndefined(params.useUnconfirmedUtxos) ? false : params.useUnconfirmedUtxos\n    // The maximum # of outputs this tx will have. It could have less if some change outputs are dropped\n    // for being too small.\n    const maxOutputCount = desiredOutputs.length + this.targetUtxoPoolSize\n    // sum of non change output value in satoshis\n    let outputTotal = 0\n    // Convert output values to satoshis for convenient math\n    const externalOutputs: BitcoinishTxOutputSatoshis[] = []\n    for (let i = 0; i < desiredOutputs.length; i++) {\n      const { address, value } = desiredOutputs[i]\n      // validate\n      if (!await this.isValidAddress(address)) {\n        throw new Error(`Invalid ${this.coinSymbol} address ${address} provided for output ${i}`)\n      }\n      const satoshis = this.toBaseDenominationNumber(value)\n      if (isNaN(satoshis)) {\n        throw new Error(`Invalid ${this.coinSymbol} value (${value}) provided to createMultiOutputTransaction output ${i} (${address})`)\n      }\n      if (satoshis <= 0) {\n        throw new Error(`Invalid ${this.coinSymbol} positive value (${value}) provided for output ${i} (${address})`)\n      }\n      externalOutputs.push({ address, satoshis })\n      outputTotal += satoshis\n    }\n    if (!await this.isValidAddress(changeAddress)) {\n      throw new Error (`Invalid ${this.coinSymbol} change address ${changeAddress} provided`)\n    }\n\n    /* Select inputs and calculate appropriate fee */\n    const availableUtxos = !useUnconfirmedUtxos\n      ? unusedUtxos.filter(isConfirmedUtxo)\n      : unusedUtxos\n    let { selectedUtxos: inputUtxos, selectedTotalSat: inputTotal, feeSat } = this.selectInputUtxos(\n      availableUtxos, outputTotal, maxOutputCount, desiredFeeRate, useAllUtxos,\n    )\n    let amountWithFee = outputTotal + feeSat\n\n    /** Account for insuffient inputs and sweeping cases */\n    if (amountWithFee > inputTotal) {\n      if (outputTotal === inputTotal) { // sweeping\n        // Share the fee across all outputs. This may increase the fee by as much as 1 sat per output, negligible\n        const feeShare = Math.ceil(feeSat / externalOutputs.length)\n        feeSat = feeShare * externalOutputs.length\n        this.logger.log(\n          `${this.coinSymbol} buildPaymentTx - Attempting to send entire ${outputTotal} sat balance. ` +\n          `Subtracting fee of ${feeSat} sat from ${externalOutputs.length} outputs (${feeShare} sat each)`\n        )\n        for (let i = 0; i < externalOutputs.length; i++) {\n          const externalOutput = externalOutputs[i]\n          externalOutput.satoshis -= feeShare\n          if (externalOutput.satoshis <= this.dustThreshold) {\n            throw new Error(\n              `${this.coinSymbol} buildPaymentTx - output ${i} for ${externalOutput.satoshis} ` +\n              `sat minus ${feeShare} sat fee share is below dust threshold`\n            )\n          }\n        }\n        amountWithFee = inputTotal\n        outputTotal -= feeSat\n      } else { // insufficient utxos\n        throw new Error(\n          `${this.coinSymbol} buildPaymentTx - You do not have enough UTXOs (${inputTotal} sat) ` +\n          `to send ${outputTotal} sat with ${feeSat} sat fee`\n        )\n      }\n    }\n\n    /** Change handling */\n\n    let totalChangeSat = inputTotal - amountWithFee\n\n    this.logger.debug('buildPaymentTx', { inputTotal, feeSat, outputTotal, totalChangeSat })\n    let changeOutputs: BitcoinishTxOutputSatoshis[] = []\n    if (totalChangeSat > this.dustThreshold) { // Avoid creating dust outputs\n\n      // Don't use availableUtxo.length here because unconfirmed still count towards pool count\n      const remainingUtxoCount = unusedUtxos.length - inputUtxos.length\n      // Determine how many change outputs to use to maintain target pool size\n      const targetChangeOutputCount = remainingUtxoCount < this.targetUtxoPoolSize\n        ? this.targetUtxoPoolSize - remainingUtxoCount\n        : 1\n\n      const changeOutputWeights = this.createWeightedChangeOutputs(targetChangeOutputCount, changeAddress)\n      const totalChangeWeight = changeOutputWeights.reduce((total, { weight }) => total += weight, 0)\n      let totalChangeAllocated = 0 // Total sat of all change outputs we actually include (omitting dust)\n      for (let i = 0; i < changeOutputWeights.length; i++) {\n        const { address, weight } = changeOutputWeights[i]\n        // Distribute change proportional to each change outputs weight. Floored to not exceed inputTotal\n        const changeSat = Math.floor(totalChangeSat * (weight / totalChangeWeight))\n        if (changeSat <= this.dustThreshold || changeSat < this.minChangeSat) {\n          this.logger.log(\n            `${this.coinSymbol} buildPaymentTx - desired change output ${i} is below dust threshold or minChange, ` +\n            'will redistribute to other change outputs or add to fee'\n          )\n        } else {\n          changeOutputs.push({ address, satoshis: changeSat })\n          totalChangeAllocated += changeSat\n        }\n      }\n      this.logger.debug({ changeOutputWeights, totalChangeWeight, totalChangeAllocated, changeOutputs })\n      // If due to rounding or omitting dust outputs our real change total is different, adjust fees accordingly\n      let looseChange = totalChangeSat - totalChangeAllocated\n      if (looseChange < 0) {\n        throw new Error(`${this.coinSymbol} buildPaymentTx - looseChange should never be negative!`)\n      } else if (changeOutputs.length > 0 && looseChange / changeOutputs.length > 1) {\n        const extraSatPerChangeOutput = Math.floor(looseChange / changeOutputs.length)\n        this.logger.log(`${this.coinSymbol} buildPaymentTx - redistributing looseChange of ${extraSatPerChangeOutput} per change output`)\n        for (let i = 0; i < changeOutputs.length; i++) {\n          changeOutputs[i].satoshis += extraSatPerChangeOutput\n        }\n        looseChange -= extraSatPerChangeOutput * changeOutputs.length\n      } else if (changeOutputs.length === 0 && looseChange > this.dustThreshold) {\n        this.logger.log(`${this.coinSymbol} buildPaymentTx - allocated looseChange towards single ${looseChange} sat change output`)\n        changeOutputs.push({ address: changeAddress, satoshis: looseChange })\n        looseChange = 0\n      }\n      feeSat += looseChange\n      totalChangeSat -= looseChange\n    } else if (totalChangeSat > 0) {\n      this.logger.log(\n        `${this.coinSymbol} buildPaymentTx - change of ${totalChangeSat} sat is below dustThreshold of ${this.dustThreshold}, adding to fee`\n      )\n      feeSat += totalChangeSat\n      totalChangeSat = 0\n    } else if (totalChangeSat < 0) {\n      throw new Error(`${this.coinSymbol} buildPaymentTx - totalChangeSat is negative when building tx, this shouldnt happen!`)\n    }\n    const externalOutputsResult = this.convertOutputsToExternalFormat(externalOutputs)\n    const changeOutputsResult = this.convertOutputsToExternalFormat(changeOutputs)\n    const outputsResult = [...externalOutputsResult, ...changeOutputsResult]\n    return {\n      inputs: inputUtxos,\n      outputs: outputsResult,\n      fee: this.toMainDenominationString(feeSat),\n      change: this.toMainDenominationString(totalChangeSat),\n      changeAddress: changeOutputs.length === 1 ? changeOutputs[0].address : null, // back compat\n      changeOutputs: changeOutputsResult,\n      externalOutputs: externalOutputsResult,\n      externalOutputTotal: this.toMainDenominationString(outputTotal),\n      rawHex: '',\n      rawHash: '',\n    }\n  }\n\n  /**\n   * Creates a list of change addresses with an exponential weight distribution to use for\n   * maintaining a pool of utxos.\n   */\n  private createWeightedChangeOutputs(\n    changeOutputCount: number,\n    changeAddress: string,\n  ): BitcoinishWeightedChangeOutput[] {\n    const result: BitcoinishWeightedChangeOutput[] = []\n    for (let i = 0; i < changeOutputCount; i++) {\n      result.push({ address: changeAddress, weight: 2 ** i })\n    }\n    return result\n  }\n\n  async createTransaction(\n    from: number,\n    to: ResolveablePayport,\n    amount: Numeric,\n    options?: CreateTransactionOptions,\n  ): Promise<BitcoinishUnsignedTransaction> {\n    return this.createMultiOutputTransaction(from, [{ payport: to, amount }], options)\n  }\n\n  async createMultiOutputTransaction(\n    from: number,\n    to: PayportOutput[],\n    options: CreateTransactionOptions = {},\n  ): Promise<BitcoinishUnsignedTransaction> {\n    assertType(t.array(PayportOutput), to)\n    this.logger.debug('createMultiOutputTransaction', from, to, options)\n\n    const unusedUtxos = options.utxos || await this.getUtxos(from)\n    this.logger.debug('createMultiOutputTransaction unusedUtxos', unusedUtxos)\n\n    const { address: fromAddress } = await this.resolvePayport(from)\n\n    const desiredOutputs = await Promise.all(to.map(async ({ payport, amount }) => ({\n      address: (await this.resolvePayport(payport)).address,\n      value: String(amount),\n    })))\n\n    const { targetFeeLevel, targetFeeRate, targetFeeRateType } = await this.resolveFeeOption(options)\n    this.logger.debug(`createMultiOutputTransaction resolvedFeeOption ${targetFeeLevel} ${targetFeeRate} ${targetFeeRateType}`)\n\n    const paymentTx = await this.buildPaymentTx({\n      unusedUtxos,\n      desiredOutputs,\n      changeAddress: fromAddress,\n      desiredFeeRate: { feeRate: targetFeeRate, feeRateType: targetFeeRateType },\n      useAllUtxos: options.useAllUtxos,\n      useUnconfirmedUtxos: options.useUnconfirmedUtxos,\n    })\n    const unsignedTxHex = await this.serializePaymentTx(paymentTx, from)\n    paymentTx.rawHex = unsignedTxHex\n    paymentTx.rawHash = sha256FromHex(unsignedTxHex)\n    this.logger.debug('createMultiOutputTransaction data', paymentTx)\n    const feeMain = paymentTx.fee\n\n    let resultToAddress = 'batch'\n    let resultToIndex = null\n    if (paymentTx.externalOutputs.length === 1) {\n      const onlyOutput = paymentTx.externalOutputs[0]\n      resultToAddress = onlyOutput.address\n      resultToIndex = isNumber(to[0].payport) ? to[0].payport : null\n    }\n\n    return {\n      status: TransactionStatus.Unsigned,\n      id: null,\n      fromIndex: from,\n      fromAddress,\n      fromExtraId: null,\n      toIndex: resultToIndex,\n      toAddress: resultToAddress,\n      toExtraId: null,\n      amount: paymentTx.externalOutputTotal,\n      targetFeeLevel,\n      targetFeeRate,\n      targetFeeRateType,\n      fee: feeMain,\n      sequenceNumber: null,\n      inputUtxos: paymentTx.inputs,\n      externalOutputs: paymentTx.externalOutputs,\n      data: paymentTx,\n    }\n  }\n\n  async createSweepTransaction(\n    from: number,\n    to: ResolveablePayport,\n    options: CreateTransactionOptions = {},\n  ): Promise<BitcoinishUnsignedTransaction> {\n    this.logger.debug('createSweepTransaction', from, to, options)\n\n    const availableUtxos = isUndefined(options.utxos)\n      ? await this.getUtxos(from)\n      : options.utxos\n\n    if (availableUtxos.length === 0) {\n      throw new Error('No available utxos to sweep')\n    }\n    const outputAmount = sumUtxoValue(availableUtxos, options.useUnconfirmedUtxos)\n    if (!this.isSweepableBalance(outputAmount)) {\n      throw new Error(`Available utxo total ${outputAmount} ${this.coinSymbol} too low to sweep`)\n    }\n    const updatedOptions = {\n      useUnconfirmedUtxos: true,\n      ...options,\n      utxos: availableUtxos,\n      useAllUtxos: true,\n    }\n    return this.createTransaction(from, to, outputAmount, updatedOptions)\n  }\n\n  async broadcastTransaction(tx: BitcoinishSignedTransaction): Promise<BitcoinishBroadcastResult> {\n    let txId: string\n    try {\n      txId = await this._retryDced(() => this.getApi().sendTx(tx.data.hex))\n      if (tx.id !== txId) {\n        this.logger.warn(`Broadcasted ${this.coinSymbol} txid ${txId} doesn't match original txid ${tx.id}`)\n      }\n    } catch(e) {\n      const message = e.message || ''\n      if (message.startsWith('-27')) {\n        txId = tx.id\n      } else {\n        throw e\n      }\n    }\n    return {\n      id: tx.id,\n    }\n  }\n\n  async getTransactionInfo(txId: string): Promise<BitcoinishTransactionInfo> {\n    const tx = await this._retryDced(() => this.getApi().getTx(txId))\n    const fee = this.toMainDenominationString(tx.fees)\n    const confirmationId = tx.blockHash || null\n    const confirmationNumber = tx.blockHeight ? String(tx.blockHeight) : undefined\n    const confirmationTimestamp = tx.blockTime ? new Date(tx.blockTime * 1000) : null\n    const isConfirmed = Boolean(tx.confirmations && tx.confirmations > 0)\n    const status = isConfirmed ? TransactionStatus.Confirmed : TransactionStatus.Pending\n    const amountSat = get(tx, 'vout.0.value', tx.value)\n    const amount = this.toMainDenominationString(amountSat)\n    const fromAddress = get(tx, 'vin.0.addresses.0')\n    if (!fromAddress) {\n      throw new Error(`Unable to determine fromAddress of ${this.coinSymbol} tx ${txId}`)\n    }\n    const toAddress = get(tx, 'vout.0.addresses.0')\n    if (!toAddress) {\n      throw new Error(`Unable to determine toAddress of ${this.coinSymbol} tx ${txId}`)\n    }\n\n    return {\n      status,\n      id: tx.txid,\n      fromIndex: null,\n      fromAddress,\n      fromExtraId: null,\n      toIndex: null,\n      toAddress,\n      toExtraId: null,\n      amount,\n      fee,\n      sequenceNumber: null,\n      confirmationId,\n      confirmationNumber,\n      confirmationTimestamp,\n      isExecuted: isConfirmed,\n      isConfirmed,\n      confirmations: tx.confirmations,\n      data: tx,\n    }\n  }\n}\n","import * as t from 'io-ts'\nimport {\n  BaseConfig, BaseUnsignedTransaction, BaseSignedTransaction, FeeRate,\n  BaseTransactionInfo, BaseBroadcastResult, UtxoInfo, KeyPairsConfigParam,\n  BaseMultisigData,\n} from '@faast/payments-common'\nimport { extendCodec, enumCodec, requiredOptionalCodec } from '@faast/ts-common'\nimport { Network as BitcoinjsNetwork, Signer as BitcoinjsSigner } from 'bitcoinjs-lib'\nimport { BlockInfoBitcoin } from 'blockbook-client'\nimport { BitcoinishPaymentTx, BlockbookConfigServer } from './bitcoinish'\nimport { PsbtInput, TransactionInput } from 'bip174/src/lib/interfaces'\n\nexport { BitcoinjsNetwork, UtxoInfo }\nexport * from './bitcoinish/types'\n\nexport type BitcoinjsKeyPair = BitcoinjsSigner & {\n  privateKey?: Buffer\n  toWIF(): string\n}\n\nexport interface PsbtInputData extends PsbtInput, TransactionInput {}\n\nexport enum AddressType {\n  Legacy = 'p2pkh',\n  SegwitP2SH = 'p2sh-p2wpkh',\n  SegwitNative = 'p2wpkh',\n  MultisigLegacy = 'p2sh-p2ms',\n  MultisigSegwitP2SH = 'p2sh-p2wsh-p2ms',\n  MultisigSegwitNative = 'p2wsh-p2ms'\n}\nexport const AddressTypeT = enumCodec<AddressType>(AddressType, 'AddressType')\n\n// For unclear reasons tsc throws TS4023 when this type is used in an external module.\n// Re-exporting the codec cast to the inferred type helps fix this.\nconst SinglesigAddressTypeT = t.keyof({\n  [AddressType.Legacy]: null,\n  [AddressType.SegwitP2SH]: null,\n  [AddressType.SegwitNative]: null,\n}, 'SinglesigAddressType')\nexport type SinglesigAddressType = t.TypeOf<typeof SinglesigAddressTypeT>\nexport const SinglesigAddressType = SinglesigAddressTypeT as t.Type<SinglesigAddressType>\n\nconst MultisigAddressTypeT = t.keyof({\n  [AddressType.MultisigLegacy]: null,\n  [AddressType.MultisigSegwitP2SH]: null,\n  [AddressType.MultisigSegwitNative]: null,\n}, 'MultisigAddressType')\nexport type MultisigAddressType = t.TypeOf<typeof MultisigAddressTypeT>\nexport const MultisigAddressType = MultisigAddressTypeT as t.Type<MultisigAddressType>\n\nexport const BitcoinPaymentsUtilsConfig = extendCodec(\n  BaseConfig,\n  {},\n  {\n    server: BlockbookConfigServer,\n  },\n  'BitcoinPaymentsUtilsConfig',\n)\nexport type BitcoinPaymentsUtilsConfig = t.TypeOf<typeof BitcoinPaymentsUtilsConfig>\n\nexport const BaseBitcoinPaymentsConfig = extendCodec(\n  BitcoinPaymentsUtilsConfig,\n  {},\n  {\n    minTxFee: FeeRate,\n    dustThreshold: t.number,\n    networkMinRelayFee: t.number,\n    targetUtxoPoolSize: t.number, // # of available utxos to try and maintain\n    minChange: t.string, // Soft minimum for each change generated to maintain utxo pool\n    maximumFeeRate: t.number, // Hard sat/byte fee cap passed to Psbt constructor\n  },\n  'BaseBitcoinPaymentsConfig',\n)\nexport type BaseBitcoinPaymentsConfig = t.TypeOf<typeof BaseBitcoinPaymentsConfig>\n\nexport const HdBitcoinPaymentsConfig = extendCodec(\n  BaseBitcoinPaymentsConfig,\n  {\n    hdKey: t.string,\n  },\n  {\n    addressType: SinglesigAddressType,\n    derivationPath: t.string,\n  },\n  'HdBitcoinPaymentsConfig',\n)\nexport type HdBitcoinPaymentsConfig = t.TypeOf<typeof HdBitcoinPaymentsConfig>\n\nexport const KeyPairBitcoinPaymentsConfig = extendCodec(\n  BaseBitcoinPaymentsConfig,\n  {\n    keyPairs: KeyPairsConfigParam,\n  },\n  {\n    addressType: SinglesigAddressType,\n  },\n  'KeyPairBitcoinPaymentsConfig',\n)\nexport type KeyPairBitcoinPaymentsConfig = t.TypeOf<typeof KeyPairBitcoinPaymentsConfig>\n\nexport const SinglesigBitcoinPaymentsConfig = t.union([\n  HdBitcoinPaymentsConfig,\n  KeyPairBitcoinPaymentsConfig,\n], 'SinglesigBitcoinPaymentsConfig')\nexport type SinglesigBitcoinPaymentsConfig = t.TypeOf<typeof SinglesigBitcoinPaymentsConfig>\n\nexport const MultisigBitcoinPaymentsConfig = extendCodec(\n  BaseBitcoinPaymentsConfig,\n  {\n    m: t.number,\n    signers: t.array(SinglesigBitcoinPaymentsConfig),\n  },\n  {\n    addressType: MultisigAddressType,\n  },\n  'MultisigBitcoinPaymentsConfig',\n)\nexport type MultisigBitcoinPaymentsConfig = t.TypeOf<typeof MultisigBitcoinPaymentsConfig>\n\nexport const BitcoinPaymentsConfig = t.union([\n  HdBitcoinPaymentsConfig,\n  KeyPairBitcoinPaymentsConfig,\n  MultisigBitcoinPaymentsConfig,\n], 'BitcoinPaymentsConfig')\nexport type BitcoinPaymentsConfig = t.TypeOf<typeof BitcoinPaymentsConfig>\n\nexport const BitcoinUnsignedTransactionData = BitcoinishPaymentTx\nexport type BitcoinUnsignedTransactionData = t.TypeOf<typeof BitcoinUnsignedTransactionData>\n\nexport const BitcoinUnsignedTransaction = extendCodec(\n  BaseUnsignedTransaction,\n  {\n    amount: t.string,\n    fee: t.string,\n    data: BitcoinUnsignedTransactionData,\n  },\n  'BitcoinUnsignedTransaction',\n)\nexport type BitcoinUnsignedTransaction = t.TypeOf<typeof BitcoinUnsignedTransaction>\n\nexport const BitcoinSignedTransactionData = requiredOptionalCodec(\n  {\n    hex: t.string,\n  },\n  {\n    // true if `hex` is a partially signed transaction, false if it's finalized\n    partial: t.boolean,\n    // sha256 hash of the unsignedHex data for facilitating multisig tx combining\n    unsignedTxHash: t.string,\n  },\n  'BitcoinSignedTransactionData',\n)\nexport type BitcoinSignedTransactionData = t.TypeOf<typeof BitcoinSignedTransactionData>\n\nexport const BitcoinSignedTransaction = extendCodec(\n  BaseSignedTransaction,\n  {\n    data: BitcoinSignedTransactionData,\n  },\n  'BitcoinSignedTransaction',\n)\nexport type BitcoinSignedTransaction = t.TypeOf<typeof BitcoinSignedTransaction>\n\nexport const BitcoinTransactionInfo = extendCodec(BaseTransactionInfo, {}, {}, 'BitcoinTransactionInfo')\nexport type BitcoinTransactionInfo = t.TypeOf<typeof BitcoinTransactionInfo>\n\nexport const BitcoinBroadcastResult = extendCodec(BaseBroadcastResult, {}, {}, 'BitcoinBroadcastResult')\nexport type BitcoinBroadcastResult = t.TypeOf<typeof BitcoinBroadcastResult>\n\nexport const BitcoinBlock = BlockInfoBitcoin\nexport type BitcoinBlock = BlockInfoBitcoin\n","import { FeeLevel, NetworkType } from '@faast/payments-common'\nimport { networks } from 'bitcoinjs-lib'\nimport { AddressType, SinglesigAddressType, MultisigAddressType } from './types';\n\nexport const PACKAGE_NAME = 'bitcoin-payments'\nexport const DECIMAL_PLACES = 8\nexport const COIN_SYMBOL = 'BTC'\nexport const COIN_NAME = 'Bitcoin'\n\n/**\n * The minimum value a transaction output must be in order to not get rejected by the network.\n *\n * Unit: `satoshis`\n */\nexport const DEFAULT_DUST_THRESHOLD = 546\n\n/**\n * The minimum fee required by *most* nodes to relay a transaction.\n *\n * Unit: `satoshis`\n */\nexport const DEFAULT_NETWORK_MIN_RELAY_FEE = 1000\n\n/** Sequence to use for each input such that RBF is opted into */\nexport const BITCOIN_SEQUENCE_RBF = 0xFFFFFFFD\n\n/**\n * The minimum fee this library should ever use for a transaction (overrides recommended levels).\n *\n * Unit: `sat/byte`\n */\nexport const DEFAULT_MIN_TX_FEE = 5\n\nexport const DEFAULT_SINGLESIG_ADDRESS_TYPE: SinglesigAddressType = AddressType.SegwitNative\nexport const DEFAULT_MULTISIG_ADDRESS_TYPE: MultisigAddressType = AddressType.MultisigSegwitNative\n\nexport const DEFAULT_DERIVATION_PATHS = {\n  [AddressType.Legacy]: \"m/44'/0'/0'\",\n  [AddressType.SegwitP2SH]: \"m/49'/0'/0'\",\n  [AddressType.SegwitNative]: \"m/84'/0'/0'\",\n}\n\nexport const DEFAULT_NETWORK = NetworkType.Mainnet\n\nexport const NETWORK_MAINNET = networks.bitcoin\nexport const NETWORK_TESTNET = networks.testnet\n\nexport const DEFAULT_MAINNET_SERVER = process.env.BITCOIN_SERVER_URL\n  ? process.env.BITCOIN_SERVER_URL.split(',')\n  : ['https://btc1.trezor.io', 'https://btc2.trezor.io']\nexport const DEFAULT_TESTNET_SERVER = process.env.BITCOIN_TESTNET_SERVER_URL\n  ? process.env.BITCOIN_TESTNET_SERVER_URL.split(',')\n  : ['https://tbtc1.trezor.io', 'https://tbtc2.trezor.io']\n\nexport const DEFAULT_FEE_LEVEL = FeeLevel.Medium\nexport const DEFAULT_SAT_PER_BYTE_LEVELS = {\n  [FeeLevel.High]: 50,\n  [FeeLevel.Medium]: 25,\n  [FeeLevel.Low]: 10,\n}\n","import { NetworkType, FeeLevel, FeeRateType, AutoFeeLevels } from '@faast/payments-common'\nimport request from 'request-promise-native'\nimport bs58 from 'bs58'\nimport { BaseBitcoinPaymentsConfig, BitcoinSignedTransaction } from './types'\nimport { BitcoinishPaymentsConfig } from './bitcoinish'\nimport {\n  DEFAULT_NETWORK,\n  NETWORK_TESTNET,\n  NETWORK_MAINNET,\n  DEFAULT_TESTNET_SERVER,\n  DEFAULT_MAINNET_SERVER,\n  COIN_SYMBOL,\n  COIN_NAME,\n  DECIMAL_PLACES,\n  DEFAULT_DUST_THRESHOLD,\n  DEFAULT_NETWORK_MIN_RELAY_FEE,\n  DEFAULT_MIN_TX_FEE,\n  DEFAULT_FEE_LEVEL,\n} from './constants'\n\nconst DEFAULT_BITCOINISH_CONFIG = {\n  coinSymbol: COIN_SYMBOL,\n  coinName: COIN_NAME,\n  decimals: DECIMAL_PLACES,\n  dustThreshold: DEFAULT_DUST_THRESHOLD,\n  networkMinRelayFee: DEFAULT_NETWORK_MIN_RELAY_FEE,\n  minTxFee: {\n    feeRate: DEFAULT_MIN_TX_FEE.toString(),\n    feeRateType: FeeRateType.BasePerWeight,\n  },\n  defaultFeeLevel: DEFAULT_FEE_LEVEL as AutoFeeLevels,\n}\n\nexport function bip32MagicNumberToPrefix(magicNum: number): string {\n  const b = Buffer.alloc(82)\n  b.writeUInt32BE(magicNum, 0)\n  return bs58.encode(b).slice(0, 4)\n}\n\nexport function toBitcoinishConfig<T extends BaseBitcoinPaymentsConfig>(config: T): BitcoinishPaymentsConfig {\n  const configWithDefaults = {\n    ...DEFAULT_BITCOINISH_CONFIG,\n    ...config,\n    network: config.network || DEFAULT_NETWORK,\n  }\n  const { network, server } = configWithDefaults\n  return {\n    ...configWithDefaults,\n    bitcoinjsNetwork: network === NetworkType.Testnet ? NETWORK_TESTNET : NETWORK_MAINNET,\n    server: typeof server !== 'undefined'\n      ? server\n      : (network === NetworkType.Testnet\n        ? DEFAULT_TESTNET_SERVER\n        : DEFAULT_MAINNET_SERVER),\n  }\n}\n\n/** Get sat/byte fee estimate from blockcypher */\nexport async function getBlockcypherFeeEstimate(feeLevel: FeeLevel, networkType: NetworkType): Promise<number> {\n  const body = await request.get(\n    `https://api.blockcypher.com/v1/btc/${networkType === NetworkType.Mainnet ? 'main' : 'test3'}`,\n    { json: true },\n  )\n  const feePerKbField = `${feeLevel}_fee_per_kb`\n  const feePerKb = body[feePerKbField]\n  if (!feePerKb) {\n    throw new Error(`Blockcypher response is missing expected field ${feePerKbField}`)\n  }\n  return feePerKb / 1000\n}\n","import { createUnitConverters } from '@faast/payments-common'\nimport * as bitcoin from 'bitcoinjs-lib'\nimport * as bip32 from 'bip32'\nimport { BitcoinjsNetwork, AddressType, BitcoinjsKeyPair, MultisigAddressType, SinglesigAddressType } from './types'\nimport { DECIMAL_PLACES } from './constants'\nimport { isString } from '@faast/ts-common';\n\nconst {\n  toMainDenominationBigNumber,\n  toMainDenominationString,\n  toMainDenominationNumber,\n  toBaseDenominationBigNumber,\n  toBaseDenominationString,\n  toBaseDenominationNumber,\n} = createUnitConverters(DECIMAL_PLACES)\n\nexport {\n  toMainDenominationBigNumber,\n  toMainDenominationString,\n  toMainDenominationNumber,\n  toBaseDenominationBigNumber,\n  toBaseDenominationString,\n  toBaseDenominationNumber,\n}\n\nexport function isValidXprv(xprv: string, network: BitcoinjsNetwork): boolean {\n  try {\n    return !bip32.fromBase58(xprv, network).isNeutered()\n  } catch(e) {\n    return false\n  }\n}\n\nexport function isValidXpub(xpub: string, network: BitcoinjsNetwork): boolean {\n  try {\n    return bip32.fromBase58(xpub, network).isNeutered()\n  } catch(e) {\n    return false\n  }\n}\n\n/** Return string error if invalid, undefined otherwise */\nexport function validateHdKey(hdKey: string, network: BitcoinjsNetwork): string | undefined {\n  try {\n    bip32.fromBase58(hdKey, network)\n  } catch(e) {\n    return e.toString()\n  }\n}\n\nexport function isValidAddress(address: string, network: BitcoinjsNetwork): boolean {\n  try {\n    bitcoin.address.toOutputScript(address, network)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nexport function isValidPublicKey(publicKey: string | Buffer, network: BitcoinjsNetwork): boolean {\n  try {\n    bitcoin.ECPair.fromPublicKey(publicKeyToBuffer(publicKey), { network })\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nexport function isValidExtraId(extraId: string): boolean {\n  return false\n}\n\nexport function publicKeyToBuffer(publicKey: string | Buffer): Buffer {\n  return isString(publicKey) ? Buffer.from(publicKey, 'hex') : publicKey\n}\n\nexport function publicKeyToString(publicKey: string | Buffer): string {\n  return isString(publicKey) ? publicKey : publicKey.toString('hex')\n}\n\nexport function getMultisigPaymentScript(\n  network: BitcoinjsNetwork,\n  addressType: MultisigAddressType,\n  pubkeys: Buffer[],\n  m: number,\n): bitcoin.payments.Payment {\n  const scriptParams = {\n    network,\n    redeem: bitcoin.payments.p2ms({\n      pubkeys: pubkeys.sort(),\n      m,\n      network,\n    })\n  }\n  switch(addressType) {\n    case AddressType.MultisigLegacy:\n      return bitcoin.payments.p2sh(scriptParams)\n    case AddressType.MultisigSegwitNative:\n      return bitcoin.payments.p2wsh(scriptParams)\n    case AddressType.MultisigSegwitP2SH:\n      return bitcoin.payments.p2sh({\n        redeem: bitcoin.payments.p2wsh(scriptParams),\n        network,\n      })\n  }\n}\n\nexport function getSinglesigPaymentScript(\n  network: BitcoinjsNetwork,\n  addressType: SinglesigAddressType,\n  pubkey: Buffer,\n): bitcoin.payments.Payment {\n  const scriptParams = { network, pubkey }\n  switch(addressType) {\n    case AddressType.Legacy:\n      return bitcoin.payments.p2pkh(scriptParams)\n    case AddressType.SegwitNative:\n      return bitcoin.payments.p2wpkh(scriptParams)\n    case AddressType.SegwitP2SH:\n      return bitcoin.payments.p2sh({\n        redeem: bitcoin.payments.p2wpkh(scriptParams),\n        network,\n      })\n  }\n}\n\nexport function publicKeyToAddress(\n  publicKey: string | Buffer,\n  network: BitcoinjsNetwork,\n  addressType: SinglesigAddressType,\n): string {\n  const pubkey = publicKeyToBuffer(publicKey)\n  const script = getSinglesigPaymentScript(network, addressType, pubkey)\n  const { address } = script\n  if (!address) {\n    throw new Error('bitcoinjs-lib address derivation returned falsy value')\n  }\n  return address\n}\n\nexport function publicKeyToKeyPair(publicKey: string | Buffer, network: BitcoinjsNetwork): BitcoinjsKeyPair {\n  return bitcoin.ECPair.fromPublicKey(publicKeyToBuffer(publicKey), { network })\n}\n\nexport function privateKeyToKeyPair(privateKey: string, network: BitcoinjsNetwork): BitcoinjsKeyPair {\n  return bitcoin.ECPair.fromWIF(privateKey, network)\n}\n\nexport function privateKeyToAddress(privateKey: string, network: BitcoinjsNetwork, addressType: SinglesigAddressType) {\n  const keyPair = privateKeyToKeyPair(privateKey, network)\n  return publicKeyToAddress(keyPair.publicKey, network, addressType)\n}\n\nexport function isValidPrivateKey(privateKey: string, network: BitcoinjsNetwork): boolean {\n  try {\n    privateKeyToKeyPair(privateKey, network)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n","import * as bitcoin from 'bitcoinjs-lib'\nimport {\n  FeeRateType, FeeRate, AutoFeeLevels, UtxoInfo, TransactionStatus, BaseMultisigData,\n} from '@faast/payments-common'\n\nimport { getBlockcypherFeeEstimate, toBitcoinishConfig } from './utils'\nimport {\n  BaseBitcoinPaymentsConfig,\n  BitcoinUnsignedTransaction,\n  BitcoinSignedTransactionData,\n  BitcoinSignedTransaction,\n  AddressType,\n  PsbtInputData,\n} from './types'\nimport {\n  DEFAULT_SAT_PER_BYTE_LEVELS, BITCOIN_SEQUENCE_RBF,\n} from './constants'\nimport { isValidAddress, isValidPrivateKey, isValidPublicKey } from './helpers'\nimport { BitcoinishPayments, BitcoinishPaymentTx } from './bitcoinish'\n\nexport abstract class BaseBitcoinPayments<Config extends BaseBitcoinPaymentsConfig> extends BitcoinishPayments<Config> {\n\n  readonly maximumFeeRate?: number\n\n  constructor(config: BaseBitcoinPaymentsConfig) {\n    super(toBitcoinishConfig(config))\n    this.maximumFeeRate = config.maximumFeeRate\n  }\n\n  abstract getPaymentScript(index: number): bitcoin.payments.Payment\n  abstract addressType: AddressType\n\n  isValidAddress(address: string): boolean {\n    return isValidAddress(address, this.bitcoinjsNetwork)\n  }\n\n  isValidPrivateKey(privateKey: string): boolean {\n    return isValidPrivateKey(privateKey, this.bitcoinjsNetwork)\n  }\n\n  isValidPublicKey(publicKey: string): boolean {\n    return isValidPublicKey(publicKey, this.bitcoinjsNetwork)\n  }\n\n  async getFeeRateRecommendation(feeLevel: AutoFeeLevels): Promise<FeeRate> {\n    let satPerByte: number\n    try {\n      satPerByte = await getBlockcypherFeeEstimate(feeLevel, this.networkType)\n    } catch (e) {\n      satPerByte = DEFAULT_SAT_PER_BYTE_LEVELS[feeLevel]\n      this.logger.warn(\n        `Failed to get bitcoin ${this.networkType} fee estimate, using hardcoded default of ${feeLevel} sat/byte -- ${e.message}`\n      )\n    }\n    return {\n      feeRate: satPerByte.toString(),\n      feeRateType: FeeRateType.BasePerWeight,\n    }\n  }\n\n  async getPsbtInputData(\n    utxo: UtxoInfo,\n    paymentScript: bitcoin.payments.Payment,\n    addressType: AddressType,\n  ): Promise<PsbtInputData> {\n    const utx = await this.getApi().getTx(utxo.txid)\n    const result: PsbtInputData = {\n      hash: utxo.txid,\n      index: utxo.vout,\n      sequence: BITCOIN_SEQUENCE_RBF,\n    }\n    if ((/p2wpkh|p2wsh/).test(addressType)) {\n      // for segwit inputs, you only need the output script and value as an object.\n      const rawUtxo = utx.vout[utxo.vout]\n      const { hex: scriptPubKey, value: rawValue } = rawUtxo\n      if (!scriptPubKey) {\n        throw new Error(`Cannot get scriptPubKey for utxo ${utxo.txid}:${utxo.vout}`)\n      }\n      const utxoValue = this.toBaseDenominationNumber(utxo.value)\n      if (String(utxoValue) !== rawValue) {\n        throw new Error(`Utxo ${utxo.txid}:${utxo.vout} has mismatched value - ${utxoValue} sat expected but network reports ${rawValue} sat`)\n      }\n      result.witnessUtxo = {\n        script: Buffer.from(scriptPubKey, 'hex'),\n        value: utxoValue,\n      }\n    } else {\n      // for non segwit inputs, you must pass the full transaction buffer\n      if (!utx.hex) {\n        throw new Error(`Cannot get raw hex of tx for utxo ${utxo.txid}:${utxo.vout}`)\n      }\n      result.nonWitnessUtxo = Buffer.from(utx.hex, 'hex')\n    }\n    if (addressType.startsWith('p2sh-p2wsh')) {\n      result.witnessScript = paymentScript.redeem!.redeem!.output\n      result.redeemScript = paymentScript.redeem!.output\n    } else if (addressType.startsWith('p2sh')) {\n      result.redeemScript = paymentScript.redeem!.output\n    } else if (addressType.startsWith('p2wsh')) {\n      result.witnessScript = paymentScript.redeem!.output\n    }\n    return result\n  }\n\n  get psbtOptions() {\n    return {\n      network: this.bitcoinjsNetwork,\n      maximumFeeRate: this.maximumFeeRate,\n    }\n  }\n\n  async buildPsbt(paymentTx: BitcoinishPaymentTx, fromIndex: number): Promise<bitcoin.Psbt> {\n    const { inputs, outputs } = paymentTx\n    const inputPaymentScript = this.getPaymentScript(fromIndex)\n\n    let psbt = new bitcoin.Psbt(this.psbtOptions)\n    for (let input of inputs) {\n      psbt.addInput(await this.getPsbtInputData(\n        input,\n        inputPaymentScript,\n        this.addressType,\n      ))\n    }\n    for (let output of outputs) {\n      psbt.addOutput({\n        address: output.address,\n        value: this.toBaseDenominationNumber(output.value)\n      })\n    }\n    return psbt\n  }\n\n  async serializePaymentTx(tx: BitcoinishPaymentTx, fromIndex: number): Promise<string> {\n    return (await this.buildPsbt(tx, fromIndex)).toHex()\n  }\n\n  validateAndFinalizeSignedTx(\n    tx: BitcoinSignedTransaction | BitcoinUnsignedTransaction,\n    psbt: bitcoin.Psbt,\n  ): BitcoinSignedTransaction {\n    if (!psbt.validateSignaturesOfAllInputs()) {\n      throw new Error('Failed to validate signatures of all inputs')\n    }\n    psbt.finalizeAllInputs()\n    const signedTx = psbt.extractTransaction()\n    const txId = signedTx.getId()\n    const txHex = signedTx.toHex()\n    const txData = tx.data\n    const unsignedTxHash = BitcoinSignedTransactionData.is(txData) ? txData.unsignedTxHash : txData.rawHash\n    return {\n      ...tx,\n      status: TransactionStatus.Signed,\n      id: txId,\n      data: {\n        hex: txHex,\n        partial: false,\n        unsignedTxHash,\n      },\n    }\n  }\n\n  updateMultisigTx(\n    tx: BitcoinSignedTransaction | BitcoinUnsignedTransaction,\n    psbt: bitcoin.Psbt,\n    signedAccountIds: string[],\n  ): BitcoinSignedTransaction {\n    const multisigData = tx.multisigData!\n    const combinedMultisigData: BaseMultisigData = {\n      ...multisigData,\n      signedAccountIds: [...signedAccountIds.values()]\n    }\n    if (signedAccountIds.length >= multisigData.m) {\n      const finalizedTx =  this.validateAndFinalizeSignedTx(tx, psbt)\n      return {\n        ...finalizedTx,\n        multisigData: combinedMultisigData,\n      }\n    }\n    const combinedHex = psbt.toHex()\n    const unsignedTxHash = BitcoinSignedTransactionData.is(tx.data) ? tx.data.unsignedTxHash : tx.data.rawHash\n    return {\n      ...tx,\n      id: '',\n      status: TransactionStatus.Signed,\n      multisigData: combinedMultisigData,\n      data: {\n        hex: combinedHex,\n        partial: true,\n        unsignedTxHash,\n      }\n    }\n  }\n\n}\n","import bitcoin, { ECPair } from 'bitcoinjs-lib'\nimport { BIP32Interface as HDNode, fromBase58 } from 'bip32'\nimport { BitcoinjsNetwork, SinglesigAddressType, BitcoinjsKeyPair } from './types'\nimport { publicKeyToAddress } from './helpers'\n\nexport { HDNode }\n\n/**\n * Split full path into array of indices\n *\n * @example \"m/44'/0'/0'/1/23\" -> [\"44'\", \"0'\", \"0'\", \"1\", \"23\"]\n */\nexport function splitDerivationPath(path: string): string[] {\n  let parts = path.split('/')\n  if (parts[0] === 'm') {\n    return parts.slice(1)\n  }\n  return parts\n}\n\n/**\n * Derive the base HDNode required for deriveKeyPair, deriveAddress, and derivePrivateKey functions\n *\n * This partially applies the derivation path starting at the already derived depth of the provided key.\n */\nexport function deriveHDNode(hdKey: string, derivationPath: string, network: BitcoinjsNetwork): HDNode {\n  const rootNode = fromBase58(hdKey, network)\n  const parts = splitDerivationPath(derivationPath).slice(rootNode.depth)\n  let node = rootNode\n  if (parts.length > 0) {\n    node = rootNode.derivePath(parts.join('/'))\n  }\n  return node\n}\n\nexport function deriveKeyPair(baseNode: HDNode, index: number, network: BitcoinjsNetwork): BitcoinjsKeyPair {\n  return baseNode.derive(0).derive(index)\n}\n\nexport function deriveAddress(\n  baseNode: HDNode, index: number, network: BitcoinjsNetwork, addressType: SinglesigAddressType,\n): string {\n  const keyPair = deriveKeyPair(baseNode, index, network)\n  return publicKeyToAddress(keyPair.publicKey, network, addressType)\n}\n\nexport function derivePrivateKey(baseNode: HDNode, index: number, network: BitcoinjsNetwork) {\n  const keyPair = deriveKeyPair(baseNode, index, network)\n  return keyPair.toWIF()\n}\n\nexport function xprvToXpub(xprv: string, derivationPath: string, network: BitcoinjsNetwork) {\n  const node = deriveHDNode(xprv, derivationPath, network)\n  return node.neutered().toBase58()\n}\n","import * as bitcoin from 'bitcoinjs-lib'\nimport {\n  TransactionStatus,\n} from '@faast/payments-common'\nimport crypto from 'crypto'\n\nimport {\n  BaseBitcoinPaymentsConfig,\n  BitcoinishPaymentTx,\n  AddressType,\n  BitcoinjsKeyPair,\n  BitcoinUnsignedTransaction,\n  BitcoinSignedTransaction,\n  SinglesigBitcoinPaymentsConfig,\n  SinglesigAddressType,\n} from './types'\nimport { toBaseDenominationNumber, publicKeyToString, getSinglesigPaymentScript } from './helpers'\nimport { BaseBitcoinPayments } from './BaseBitcoinPayments'\nimport { DEFAULT_SINGLESIG_ADDRESS_TYPE } from './constants'\n\nexport abstract class SinglesigBitcoinPayments<Config extends SinglesigBitcoinPaymentsConfig>\n  extends BaseBitcoinPayments<Config> {\n\n  addressType: SinglesigAddressType\n\n  constructor(config: SinglesigBitcoinPaymentsConfig) {\n    super(config)\n    this.addressType = config.addressType || DEFAULT_SINGLESIG_ADDRESS_TYPE\n  }\n\n  abstract getKeyPair(index: number): BitcoinjsKeyPair\n\n  getPaymentScript(index: number) {\n    return getSinglesigPaymentScript(this.bitcoinjsNetwork, this.addressType, this.getKeyPair(index).publicKey)\n  }\n\n  signMultisigTransaction(\n    tx: BitcoinUnsignedTransaction,\n  ): BitcoinSignedTransaction {\n    const { multisigData, data } = tx\n    const { rawHex } = data\n\n    if (!multisigData) throw new Error('Not a multisig tx')\n    if (!rawHex) throw new Error('Cannot sign multisig tx without unsigned tx hex')\n\n    const psbt = bitcoin.Psbt.fromHex(rawHex, this.psbtOptions)\n    const accountId = this.getAccountId(tx.fromIndex)\n    const accountIdIndex = multisigData.accountIds.findIndex((x) => x === accountId)\n    if (accountIdIndex === -1) {\n      throw new Error('Not a signer for provided multisig tx')\n    }\n    const signedAccountIds = [...multisigData.signedAccountIds]\n    if (signedAccountIds.includes(accountId)) {\n      throw new Error('Already signed multisig tx')\n    }\n    const keyPair = this.getKeyPair(tx.fromIndex)\n    const publicKeyString = publicKeyToString(keyPair.publicKey)\n    const signerPublicKey = multisigData.publicKeys[accountIdIndex]\n    if (signerPublicKey !== publicKeyString) {\n      throw new Error(\n        `Mismatched publicKey for keyPair ${accountId}/${tx.fromIndex} - `\n        + `multisigData has ${signerPublicKey} but keyPair has ${publicKeyString}`\n      )\n    }\n    psbt.signAllInputs(keyPair)\n    signedAccountIds.push(accountId)\n    return this.updateMultisigTx(tx, psbt, signedAccountIds)\n  }\n\n  async signTransaction(tx: BitcoinUnsignedTransaction): Promise<BitcoinSignedTransaction> {\n    if (tx.multisigData) {\n      return this.signMultisigTransaction(tx)\n    }\n    const paymentTx = tx.data as BitcoinishPaymentTx\n    if (!paymentTx.rawHex) {\n      throw new Error('Cannot sign bitcoin tx without rawHex')\n    }\n    const psbt = bitcoin.Psbt.fromHex(paymentTx.rawHex, this.psbtOptions)\n\n    const keyPair = this.getKeyPair(tx.fromIndex)\n    psbt.signAllInputs(keyPair)\n\n    return this.validateAndFinalizeSignedTx(tx, psbt)\n  }\n}\n","import { omit } from 'lodash'\nimport {\n  assertType,\n} from '@faast/ts-common'\nimport bs58 from 'bs58'\nimport { xprvToXpub, deriveAddress, HDNode, deriveHDNode, deriveKeyPair } from './bip44'\nimport { HdBitcoinPaymentsConfig, SinglesigAddressType } from './types'\nimport { SinglesigBitcoinPayments } from './SinglesigBitcoinPayments'\nimport { DEFAULT_DERIVATION_PATHS, DEFAULT_SINGLESIG_ADDRESS_TYPE } from './constants'\nimport { isValidXprv, isValidXpub, validateHdKey } from './helpers';\nimport { bip32MagicNumberToPrefix } from './utils'\n\nexport class HdBitcoinPayments extends SinglesigBitcoinPayments<HdBitcoinPaymentsConfig> {\n  readonly derivationPath: string\n  readonly xpub: string\n  readonly xprv: string | null\n  readonly hdNode: HDNode\n\n  constructor(private config: HdBitcoinPaymentsConfig) {\n    super(config)\n    assertType(HdBitcoinPaymentsConfig, config)\n    this.derivationPath = config.derivationPath || DEFAULT_DERIVATION_PATHS[this.addressType]\n\n    if (this.isValidXpub(config.hdKey)) {\n      this.xpub = config.hdKey\n      this.xprv = null\n    } else if (this.isValidXprv(config.hdKey)) {\n      this.xpub = xprvToXpub(config.hdKey, this.derivationPath, this.bitcoinjsNetwork)\n      this.xprv = config.hdKey\n    } else {\n      const providedPrefix = config.hdKey.slice(0, 4)\n      const xpubPrefix = bip32MagicNumberToPrefix(this.bitcoinjsNetwork.bip32.public)\n      const xprvPrefix = bip32MagicNumberToPrefix(this.bitcoinjsNetwork.bip32.private)\n      let reason = ''\n      if (providedPrefix !== xpubPrefix && providedPrefix !== xprvPrefix) {\n        reason = ` with prefix ${providedPrefix} but expected ${xprvPrefix} or ${xpubPrefix}`\n      } else {\n        reason = ` (${validateHdKey(config.hdKey, this.bitcoinjsNetwork)})`\n      }\n      throw new Error(\n        `Invalid ${this.networkType} hdKey provided to bitcoin payments config${reason}`\n      )\n    }\n    this.hdNode = deriveHDNode(config.hdKey, this.derivationPath, this.bitcoinjsNetwork)\n  }\n\n  isValidXprv(xprv: string) {\n    return isValidXprv(xprv, this.bitcoinjsNetwork)\n  }\n\n  isValidXpub(xpub: string) {\n    return isValidXpub(xpub, this.bitcoinjsNetwork)\n  }\n\n  getFullConfig(): HdBitcoinPaymentsConfig {\n    return {\n      ...this.config,\n      network: this.networkType,\n      addressType: this.addressType,\n      derivationPath: this.derivationPath,\n    }\n  }\n\n  getPublicConfig(): HdBitcoinPaymentsConfig {\n    return {\n      ...omit(this.getFullConfig(), ['logger', 'server', 'hdKey']),\n      hdKey: this.xpub,\n    }\n  }\n  getAccountId(index: number): string {\n    return this.xpub\n  }\n  getAccountIds(index?: number): string[] {\n    return [this.xpub]\n  }\n\n  getAddress(index: number): string {\n    return deriveAddress(this.hdNode, index, this.bitcoinjsNetwork, this.addressType)\n  }\n\n  getKeyPair(index: number) {\n    return deriveKeyPair(this.hdNode, index, this.bitcoinjsNetwork)\n  }\n}\n","import { BitcoinishPaymentsUtils } from './bitcoinish'\nimport { toBitcoinishConfig } from './utils'\nimport { BitcoinPaymentsUtilsConfig } from './types'\nimport { isValidAddress, isValidPrivateKey } from './helpers'\n\nexport class BitcoinPaymentsUtils extends BitcoinishPaymentsUtils {\n  constructor(config: BitcoinPaymentsUtilsConfig = {}) {\n    super(toBitcoinishConfig(config))\n  }\n\n  async isValidAddress(address: string) {\n    return isValidAddress(address, this.bitcoinjsNetwork)\n  }\n\n  async isValidPrivateKey(privateKey: string) {\n    return isValidPrivateKey(privateKey, this.bitcoinjsNetwork)\n  }\n\n}\n","import { SinglesigBitcoinPayments } from './SinglesigBitcoinPayments'\nimport { KeyPairBitcoinPaymentsConfig, BitcoinjsKeyPair } from './types'\nimport { omit } from 'lodash'\nimport {\n  privateKeyToKeyPair,\n  publicKeyToAddress,\n  publicKeyToKeyPair,\n  publicKeyToString,\n} from './helpers'\nimport { isUndefined, isString } from '@faast/ts-common'\n\nexport class KeyPairBitcoinPayments extends SinglesigBitcoinPayments<KeyPairBitcoinPaymentsConfig> {\n  readonly publicKeys: { [index: number]: string | undefined } = {}\n  readonly privateKeys: { [index: number]: string | null | undefined } = {}\n  readonly addresses: { [index: number]: string | undefined } = {}\n\n  constructor(private config: KeyPairBitcoinPaymentsConfig) {\n    super(config)\n\n    Object.entries(config.keyPairs).forEach(([key, value]) => {\n      if (typeof value === 'undefined' || value === null) {\n        return\n      }\n\n      const i = Number.parseInt(key)\n      let publicKey: string | Buffer\n      let privateKey: string | null = null\n\n      if (this.isValidPublicKey(value)) {\n        publicKey = value\n      } else if (this.isValidPrivateKey(value)) {\n        publicKey = privateKeyToKeyPair(value, this.bitcoinjsNetwork).publicKey\n        privateKey = value\n      } else {\n        throw new Error(`KeyPairBitcoinPaymentsConfig.keyPairs[${i}] is not a valid ${this.networkType} private key or address`)\n      }\n\n      const address = publicKeyToAddress(publicKey, this.bitcoinjsNetwork, this.addressType)\n\n      this.publicKeys[i] = publicKeyToString(publicKey)\n      this.privateKeys[i] = privateKey\n      this.addresses[i] = address\n    })\n  }\n\n  getFullConfig(): KeyPairBitcoinPaymentsConfig {\n    return {\n      ...this.config,\n      network: this.networkType,\n      addressType: this.addressType,\n    }\n  }\n\n  getPublicConfig(): KeyPairBitcoinPaymentsConfig {\n    return {\n      ...omit(this.getFullConfig(), ['logger', 'server', 'keyPairs']),\n      keyPairs: this.publicKeys,\n    }\n  }\n\n  getAccountId(index: number): string {\n    const accountId = this.publicKeys[index] || ''\n    if (!accountId) {\n      throw new Error(`No KeyPairBitcoinPayments account configured at index ${index}`)\n    }\n    return accountId\n  }\n\n  getAccountIds(index?: number): string[] {\n    if (!isUndefined(index)) {\n      return [this.getAccountId(index)]\n    }\n    return Object.values(this.publicKeys).filter(isString)\n  }\n\n  getKeyPair(index: number): BitcoinjsKeyPair {\n    const privateKey = this.privateKeys[index]\n    if (privateKey) {\n      return privateKeyToKeyPair(privateKey, this.bitcoinjsNetwork)\n    }\n    const publicKey = this.publicKeys[index] || ''\n    if (!this.isValidPublicKey(publicKey)) {\n      throw new Error(`Cannot get publicKey ${index} - keyPair[${index}] is undefined or invalid`)\n    }\n    return publicKeyToKeyPair(publicKey, this.bitcoinjsNetwork)\n  }\n\n  getAddress(index: number): string {\n    const address = this.addresses[index] || ''\n    if (!this.isValidAddress(address)) {\n      throw new Error(`Cannot get address ${index} - keyPair[${index}] is undefined or invalid address`)\n    }\n    return address\n  }\n\n  getPrivateKey(index: number): string {\n    const privateKey = this.privateKeys[index] || ''\n    if (!this.isValidPrivateKey(privateKey)) {\n      throw new Error(`Cannot get private key ${index} - keyPair[${index}] is undefined`)\n    }\n    return privateKey\n  }\n}\n\nexport default KeyPairBitcoinPayments\n","import { BaseBitcoinPayments } from './BaseBitcoinPayments'\nimport {\n  MultisigBitcoinPaymentsConfig,\n  HdBitcoinPaymentsConfig,\n  BitcoinUnsignedTransaction,\n  BitcoinSignedTransaction,\n  PayportOutput,\n  MultisigAddressType,\n} from './types'\nimport { omit } from 'lodash'\nimport { HdBitcoinPayments } from './HdBitcoinPayments'\nimport { KeyPairBitcoinPayments } from './KeyPairBitcoinPayments'\nimport * as bitcoin from 'bitcoinjs-lib'\nimport { CreateTransactionOptions, ResolveablePayport, BaseMultisigData } from '@faast/payments-common'\nimport { publicKeyToString, getMultisigPaymentScript } from './helpers'\nimport { Numeric } from '@faast/ts-common'\nimport { DEFAULT_MULTISIG_ADDRESS_TYPE } from './constants'\n\nexport class MultisigBitcoinPayments extends BaseBitcoinPayments<MultisigBitcoinPaymentsConfig> {\n\n  addressType: MultisigAddressType\n  m: number\n  signers: (HdBitcoinPayments | KeyPairBitcoinPayments)[]\n  accountIdToSigner: { [accountId: string]: HdBitcoinPayments | KeyPairBitcoinPayments } = {}\n\n  constructor(private config: MultisigBitcoinPaymentsConfig) {\n    super(config)\n    this.addressType = config.addressType || DEFAULT_MULTISIG_ADDRESS_TYPE\n    this.m = config.m\n    this.signers = config.signers.map((signerConfig, i) => {\n      signerConfig = {\n        network: this.networkType,\n        logger: this.logger,\n        ...signerConfig,\n      }\n      if (signerConfig.network !== this.networkType) {\n        throw new Error(`MultisigBitcoinPayments is on network ${this.networkType} but signer config ${i} is on ${signerConfig.network}`)\n      }\n      const payments = HdBitcoinPaymentsConfig.is(signerConfig)\n        ? new HdBitcoinPayments(signerConfig)\n        : new KeyPairBitcoinPayments(signerConfig)\n\n      payments.getAccountIds().forEach((accountId) => {\n        this.accountIdToSigner[accountId] = payments\n      })\n      return payments\n    })\n  }\n\n  getFullConfig(): MultisigBitcoinPaymentsConfig {\n    return {\n      ...this.config,\n      network: this.networkType,\n      addressType: this.addressType,\n    }\n  }\n\n  getPublicConfig(): MultisigBitcoinPaymentsConfig {\n    return {\n      ...omit(this.getFullConfig(), ['logger', 'server', 'signers']),\n      signers: this.signers.map((signer) => signer.getPublicConfig()),\n    }\n  }\n\n  getAccountId(index: number): string {\n    throw new Error('Multisig payments does not have single account for an index, use getAccountIds(index) instead')\n  }\n\n  getAccountIds(index?: number): string[] {\n    return this.signers.reduce((result, signer) => ([...result, ...signer.getAccountIds(index)]), [] as string[])\n  }\n\n  getSignerPublicKeyBuffers(index: number): Buffer[] {\n    return this.signers.map((signer) => signer.getKeyPair(index).publicKey)\n  }\n\n  getPaymentScript(index: number): bitcoin.payments.Payment {\n    return getMultisigPaymentScript(\n      this.bitcoinjsNetwork,\n      this.addressType,\n      this.getSignerPublicKeyBuffers(index),\n      this.m,\n    )\n  }\n\n  getAddress(index: number): string {\n    const { address } = this.getPaymentScript(index)\n    if (!address) {\n      throw new Error('bitcoinjs-lib address derivation returned falsy value')\n    }\n    return address\n  }\n\n  private createMultisigData(index: number): BaseMultisigData {\n    return {\n      m: this.m,\n      accountIds: this.signers.map((signer) => signer.getAccountId(index)),\n      publicKeys: this.signers.map((signer) => publicKeyToString(signer.getKeyPair(index).publicKey)),\n      signedAccountIds: [],\n    }\n  }\n\n  async createTransaction(\n    from: number,\n    to: ResolveablePayport,\n    amount: Numeric,\n    options?: CreateTransactionOptions,\n  ): Promise<BitcoinUnsignedTransaction> {\n    const tx = await super.createTransaction(from, to, amount, options)\n    return {\n      ...tx,\n      multisigData: this.createMultisigData(from),\n    }\n  }\n\n  async createMultiOutputTransaction(\n    from: number,\n    to: PayportOutput[],\n    options: CreateTransactionOptions = {},\n  ): Promise<BitcoinUnsignedTransaction> {\n    const tx = await super.createMultiOutputTransaction(from, to, options)\n    return {\n      ...tx,\n      multisigData: this.createMultisigData(from),\n    }\n  }\n\n  async createSweepTransaction(\n    from: number,\n    to: ResolveablePayport,\n    options: CreateTransactionOptions = {},\n  ): Promise<BitcoinUnsignedTransaction> {\n    const tx = await super.createSweepTransaction(from, to, options)\n    return {\n      ...tx,\n      multisigData: this.createMultisigData(from),\n    }\n  }\n\n  private deserializeSignedTxPsbt(tx: BitcoinSignedTransaction): bitcoin.Psbt {\n    if (!tx.data.partial) {\n      throw new Error('Cannot decode psbt of a finalized tx')\n    }\n    return bitcoin.Psbt.fromHex(tx.data.hex, this.psbtOptions)\n  }\n\n  /**\n   * Combines two of more partially signed transactions. Once the required # of signatures is reached (`m`)\n   * the transaction is validated and finalized.\n   */\n  async combinePartiallySignedTransactions(txs: BitcoinSignedTransaction[]): Promise<BitcoinSignedTransaction> {\n    if (txs.length < 2) {\n      throw new Error(`Cannot combine ${txs.length} transactions, need at least 2`)\n    }\n\n    const unsignedTxHash = txs[0].data.unsignedTxHash\n    txs.forEach(({ multisigData, inputUtxos, externalOutputs, data }, i) => {\n      if (!multisigData) throw new Error(`Cannot combine signed multisig tx ${i} because multisigData is ${multisigData}`)\n      if (!inputUtxos) throw new Error(`Cannot combine signed multisig tx ${i} because inputUtxos field is missing`)\n      if (!externalOutputs) throw new Error(`Cannot combine signed multisig tx ${i} because externalOutputs field is missing`)\n      if (data.unsignedTxHash !== unsignedTxHash) throw new Error(`Cannot combine signed multisig tx ${i} because unsignedTxHash is ${data.unsignedTxHash} when expecting ${unsignedTxHash}`)\n      if (!data.partial) throw new Error(`Cannot combine signed multisig tx ${i} because partial is ${data.partial}`)\n    })\n\n    const baseTx = txs[0]\n    const baseTxMultisigData = baseTx.multisigData!\n    const { m } = baseTxMultisigData\n    const signedAccountIds = new Set(baseTxMultisigData.signedAccountIds)\n\n    let combinedPsbt = this.deserializeSignedTxPsbt(baseTx)\n    for (let i = 1; i < txs.length; i++) {\n      if (signedAccountIds.size >= m) {\n        this.logger.debug('Already received enough signatures, not combining')\n        break\n      }\n      const tx = txs[i]\n      const psbt = this.deserializeSignedTxPsbt(tx)\n      combinedPsbt.combine(psbt)\n      tx.multisigData!.signedAccountIds.forEach((accountId) => signedAccountIds.add(accountId))\n    }\n\n    return this.updateMultisigTx(baseTx, combinedPsbt, [...signedAccountIds.values()])\n  }\n\n  async signTransaction(tx: BitcoinUnsignedTransaction): Promise<BitcoinSignedTransaction> {\n    const partiallySignedTxs = await Promise.all(this.signers.map((signer) => signer.signTransaction(tx)))\n    return this.combinePartiallySignedTransactions(partiallySignedTxs)\n  }\n}\n\nexport default MultisigBitcoinPayments\n","import { PaymentsFactory } from '@faast/payments-common'\n\nimport {\n  BitcoinPaymentsConfig,\n  HdBitcoinPaymentsConfig,\n  KeyPairBitcoinPaymentsConfig,\n  MultisigBitcoinPaymentsConfig,\n} from './types'\nimport { HdBitcoinPayments } from './HdBitcoinPayments'\nimport { KeyPairBitcoinPayments } from './KeyPairBitcoinPayments'\nimport { MultisigBitcoinPayments } from './MultisigBitcoinPayments'\n\nexport class BitcoinPaymentsFactory implements PaymentsFactory<BitcoinPaymentsConfig> {\n  forConfig(config: BitcoinPaymentsConfig) {\n    if (HdBitcoinPaymentsConfig.is(config)) {\n      return new HdBitcoinPayments(config)\n    }\n    if (KeyPairBitcoinPaymentsConfig.is(config)) {\n      return new KeyPairBitcoinPayments(config)\n    }\n    if (MultisigBitcoinPaymentsConfig.is(config)) {\n      return new MultisigBitcoinPayments(config)\n    }\n    throw new Error('Cannot instantiate bitcoin payments for unsupported config')\n  }\n}\n\nexport default BitcoinPaymentsFactory\n"],"names":["t.union","t.string","t.array","t.null","t.type","t.number","t.keyof","t.boolean","bip32.fromBase58","address","bitcoin.address","bitcoin.ECPair","bitcoin.payments","bitcoin.Psbt"],"mappings":"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"}